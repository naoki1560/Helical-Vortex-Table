<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Helical Vortex Periodic Table</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: "Helvetica Neue", Arial, sans-serif; }
        
        /* タイトルヘッダー */
        #info {
            position: absolute; top: 0; left: 0; width: 100%;
            pointer-events: none; z-index: 10; padding: 15px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0) 100%);
        }
        h1 { margin: 0; font-size: 18px; color: #00ffff; letter-spacing: 1px; text-shadow: 0 0 5px #00ffff; }
        #status { font-size: 14px; color: #ff00ff; font-weight: bold; margin-top: 5px; display:block; }
        
        /* 凡例（左下に配置変更） */
        #legend {
            position: absolute; bottom: 20px; left: 20px;
            pointer-events: none; font-size: 11px; z-index: 10;
        }
        .key-item { margin-bottom: 5px; opacity: 0.8; }
        .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 6px; }

        /* ★理論ボタン（右下） */
        #theory-btn {
            position: absolute; bottom: 20px; right: 20px;
            background: rgba(0, 255, 255, 0.1); border: 1px solid #00ffff;
            color: #00ffff; padding: 10px 20px; border-radius: 30px;
            font-size: 12px; cursor: pointer; z-index: 20;
            backdrop-filter: blur(5px); transition: all 0.3s;
        }
        #theory-btn:active { background: #00ffff; color: #000; }

        /* ★理論モーダル（解説画面） */
        #modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 30;
            justify-content: center; align-items: center;
            padding: 20px; box-sizing: border-box;
        }
        #modal-content {
            background: #111; border: 1px solid #333; padding: 25px;
            max-width: 500px; width: 100%; border-radius: 8px;
            position: relative; box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }
        #close-btn {
            position: absolute; top: 10px; right: 15px; font-size: 24px; color: #666; cursor: pointer;
        }
        h2 { color: #00ffff; margin-top: 0; font-size: 18px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .theory-text { font-size: 14px; line-height: 1.6; color: #ccc; margin-bottom: 15px; }
        strong { color: #fff; }
    </style>
</head>
<body>
    <div id="info">
        <h1>Helical Vortex Periodic Table</h1>
        <span id="status">Tap atom for details</span>
    </div>

    <div id="legend">
        <div class="key-item"><span class="dot" style="background:#ff4444;"></span>s-block</div>
        <div class="key-item"><span class="dot" style="background:#ffff44;"></span>p-block</div>
        <div class="key-item"><span class="dot" style="background:#4444ff;"></span>d-block</div>
        <div class="key-item"><span class="dot" style="background:#44ff44;"></span>f-block</div>
    </div>

    <button id="theory-btn">THEORY & VALUE</button>

    <div id="modal">
        <div id="modal-content">
            <span id="close-btn">&times;</span>
            <h2>Why Helical Vortex?</h2>
            
            <div class="theory-text">
                <p><strong>1. Continuity of Matter</strong><br>
                The standard periodic table creates artificial breaks (e.g., Ne to Na). This helical model visualizes the atomic number (Z) as a <strong>continuous, unbroken flow</strong>, reflecting the true nature of nuclear accumulation.</p>
                
                <p><strong>2. Integration of f-block</strong><br>
                Lanthanides and Actinides are often exiled to the bottom of standard tables. Here, they are naturally integrated into the flow, visualizing the <strong>correct energy sequence</strong> (s &rarr; f &rarr; d &rarr; p).</p>
                
                <p><strong>3. Periodicity as a Cycle</strong><br>
                By viewing from the top (axial view), elements of the same group align perfectly, demonstrating that periodicity is essentially a <strong>cycle in a vortex</strong>, not a grid.</p>
            </div>
            <div style="font-size:12px; color:#666; text-align:right;">Designed by Naoki Kiryu</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        const symbols = ["","H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr","Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe","Cs","Ba","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu","Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn","Fr","Ra","Ac","Th","Pa","U","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr","Rf","Db","Sg","Bh","Hs","Mt","Ds","Rg","Cn","Nh","Fl","Mc","Lv","Ts","Og"];
        
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 30, 140);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; 
        controls.dampingFactor = 0.15;
        controls.rotateSpeed = 1.5;
        controls.panSpeed = 1.8;
        controls.screenSpacePanning = true;

        scene.add(new THREE.AmbientLight(0xaaaaaa));
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(10, 50, 50);
        scene.add(light);

        const elements = [];
        const colors = { s: 0xff4444, p: 0xffff44, d: 0x4444ff, f: 0x44ff44, future: 0xff00ff };
        const clickableObjects = [];
        const spiralPoints = [];

        for (let z = 1; z <= 126; z++) {
            let color = colors.d;
            let type = "d";
            if ([1,2,3,4,11,12,19,20,37,38,55,56,87,88,119,120].includes(z)) { color = colors.s; type="s"; }
            else if ([5,6,7,8,9,10,13,14,15,16,17,18,31,32,33,34,35,36,49,50,51,52,53,54,81,82,83,84,85,86,113,114,115,116,117,118].includes(z)) { color = colors.p; type="p"; }
            else if ((z >= 57 && z <= 71) || (z >= 89 && z <= 103)) { color = colors.f; type="f"; }
            else if (z > 118) { color = colors.future; type="Future"; }

            // 形状：平たい渦巻き状
            const maxR = 60;
            const radius = maxR - (z * 0.35);
            const theta = z * 0.55;
            const y = -z * 0.5 + 30;
            const x = radius * Math.cos(theta);
            const z_pos = radius * Math.sin(theta);

            elements.push({ z: z, color: color, type: type, pos: new THREE.Vector3(x, y, z_pos) });
            spiralPoints.push(new THREE.Vector3(x, y, z_pos));
        }

        const atomGeo = new THREE.SphereGeometry(1.5, 12, 12);
        const group = new THREE.Group();

        function makeLabel(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 64; canvas.height = 64;
            ctx.fillStyle = "white";
            ctx.font = "bold 48px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text, 32, 32);
            const texture = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: texture, sizeAttenuation: false, depthTest: false });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(0.025, 0.025, 1); 
            return sprite;
        }

        elements.forEach(el => {
            const mat = new THREE.MeshPhongMaterial({ color: el.color });
            const atom = new THREE.Mesh(atomGeo, mat);
            atom.position.copy(el.pos);
            atom.userData = { id: el.z, type: el.type };
            group.add(atom);
            clickableObjects.push(atom);

            const label = makeLabel(symbols[el.z] || String(el.z));
            label.position.copy(el.pos); 
            label.center.set(0.5, -0.5); 
            group.add(label);
        });

        const lineGeo = new THREE.BufferGeometry().setFromPoints(spiralPoints);
        const lineMat = new THREE.LineBasicMaterial({ color: 0x444444, opacity: 0.5, transparent: true });
        scene.add(new THREE.Line(lineGeo, lineMat));
        scene.add(group);

        // クリック/タップ判定
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let touchStartX=0, touchStartY=0;

        renderer.domElement.addEventListener('touchstart', (e)=>{
            if(e.touches.length===1){ touchStartX=e.touches[0].clientX; touchStartY=e.touches[0].clientY; }
        }, {passive:false});

        renderer.domElement.addEventListener('touchend', (e)=>{
            if(e.changedTouches.length===1){
                const dx=e.changedTouches[0].clientX-touchStartX;
                const dy=e.changedTouches[0].clientY-touchStartY;
                if(Math.abs(dx)<10 && Math.abs(dy)<10){ checkIntersects(e.changedTouches[0].clientX, e.changedTouches[0].clientY); }
            }
        });
        renderer.domElement.addEventListener('click', (e)=>{ checkIntersects(e.clientX, e.clientY); });

        function checkIntersects(x, y) {
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(clickableObjects);
            if (intersects.length > 0) {
                const data = intersects[0].object.userData;
                const sym = symbols[data.id] || "";
                document.getElementById('status').innerHTML = `No.${data.id} <span style="font-size:1.2em; color:#fff;">${sym}</span> [${data.type}-block]`;
                const originalColor = intersects[0].object.material.color.getHex();
                intersects[0].object.material.emissive.setHex(0xffffff);
                setTimeout(() => { intersects[0].object.material.emissive.setHex(0x000000); }, 200);
            }
        }

        // モーダル制御
        const modal = document.getElementById('modal');
        const btn = document.getElementById('theory-btn');
        const close = document.getElementById('close-btn');

        btn.onclick = function() { modal.style.display = "flex"; }
        close.onclick = function() { modal.style.display = "none"; }
        window.onclick = function(event) { if (event.target == modal) { modal.style.display = "none"; } }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
