<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Helical Vortex Periodic Table</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: sans-serif; }
        
        /* インターフェース */
        #info {
            position: absolute; top: 0; left: 0; width: 100%;
            pointer-events: none; z-index: 10; padding: 10px;
            box-sizing: border-box;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
        }
        h1 { margin: 0; font-size: 16px; color: #00ffff; display: inline-block; margin-right: 15px; }
        #status { 
            font-size: 16px; color: #ff00ff; font-weight: bold; 
            background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 4px;
        }
        
        #legend {
            position: absolute; bottom: 10px; right: 10px;
            background: rgba(0, 0, 0, 0.6); padding: 8px;
            border-radius: 4px; pointer-events: none; font-size: 10px;
        }
        .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 4px; }
        .item { display: inline-block; margin-right: 10px; }
    </style>
</head>
<body>
    <div id="info">
        <h1>Helical Vortex</h1>
        <span id="status">Tap atom for details</span>
    </div>

    <div id="legend">
        <span class="item"><span class="dot" style="background:#ff4444;"></span>s</span>
        <span class="item"><span class="dot" style="background:#ffff44;"></span>p</span>
        <span class="item"><span class="dot" style="background:#4444ff;"></span>d</span>
        <span class="item"><span class="dot" style="background:#44ff44;"></span>f</span>
        <span class="item"><span class="dot" style="background:#ff00ff;"></span>Future</span>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        const symbols = ["","H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr","Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe","Cs","Ba","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu","Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn","Fr","Ra","Ac","Th","Pa","U","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr","Rf","Db","Sg","Bh","Hs","Mt","Ds","Rg","Cn","Nh","Fl","Mc","Lv","Ts","Og"];
        
        // シーン設定
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 20, 150); // カメラ位置も少し低めに調整

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // 操作設定（キビキビ動くまま）
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; 
        controls.dampingFactor = 0.15;
        controls.rotateSpeed = 1.5;
        controls.panSpeed = 1.8;
        controls.screenSpacePanning = true;

        scene.add(new THREE.AmbientLight(0xaaaaaa));
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(10, 50, 50);
        scene.add(light);

        const elements = [];
        const colors = { s: 0xff4444, p: 0xffff44, d: 0x4444ff, f: 0x44ff44, future: 0xff00ff };
        const clickableObjects = [];
        const spiralPoints = [];

        for (let z = 1; z <= 126; z++) {
            let color = colors.d;
            let type = "d";
            if ([1,2,3,4,11,12,19,20,37,38,55,56,87,88,119,120].includes(z)) { color = colors.s; type="s"; }
            else if ([5,6,7,8,9,10,13,14,15,16,17,18,31,32,33,34,35,36,49,50,51,52,53,54,81,82,83,84,85,86,113,114,115,116,117,118].includes(z)) { color = colors.p; type="p"; }
            else if ((z >= 57 && z <= 71) || (z >= 89 && z <= 103)) { color = colors.f; type="f"; }
            else if (z > 118) { color = colors.future; type="Future"; }

            // ★修正ポイント：縦の長さの計算
            const maxR = 60;
            const radius = maxR - (z * 0.35);
            const theta = z * 0.55;
            
            // ここを変更：0.9倍だったのを0.5倍にして圧縮
            const y = -z * 0.5 + 30; 
            
            const x = radius * Math.cos(theta);
            const z_pos = radius * Math.sin(theta);

            elements.push({ z: z, color: color, type: type, pos: new THREE.Vector3(x, y, z_pos) });
            spiralPoints.push(new THREE.Vector3(x, y, z_pos));
        }

        const atomGeo = new THREE.SphereGeometry(1.5, 12, 12);
        const group = new THREE.Group();

        function makeLabel(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 64; canvas.height = 64;
            ctx.fillStyle = "white";
            ctx.font = "bold 48px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text, 32, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: texture, sizeAttenuation: false, depthTest: false });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(0.025, 0.025, 1); 
            return sprite;
        }

        elements.forEach(el => {
            const mat = new THREE.MeshPhongMaterial({ color: el.color });
            const atom = new THREE.Mesh(atomGeo, mat);
            atom.position.copy(el.pos);
            atom.userData = { id: el.z, type: el.type };
            group.add(atom);
            clickableObjects.push(atom);

            const label = makeLabel(symbols[el.z] || String(el.z));
            label.position.copy(el.pos); 
            label.center.set(0.5, -0.5); 
            group.add(label);
        });

        const lineGeo = new THREE.BufferGeometry().setFromPoints(spiralPoints);
        const lineMat = new THREE.LineBasicMaterial({ color: 0x444444, opacity: 0.5, transparent: true });
        scene.add(new THREE.Line(lineGeo, lineMat));
        scene.add(group);

        // iPad用クリック判定（前回同様）
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let touchStartX = 0, touchStartY = 0;

        renderer.domElement.addEventListener('touchstart', (e) => {
            if(e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }
        }, {passive: false});

        renderer.domElement.addEventListener('touchend', (e) => {
            if(e.changedTouches.length === 1) {
                const dx = e.changedTouches[0].clientX - touchStartX;
                const dy = e.changedTouches[0].clientY - touchStartY;
                if (Math.abs(dx) < 10 && Math.abs(dy) < 10) {
                    checkIntersects(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
                }
            }
        });

        renderer.domElement.addEventListener('click', (e) => {
            checkIntersects(e.clientX, e.clientY);
        });

        function checkIntersects(x, y) {
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(clickableObjects);
            if (intersects.length > 0) {
                const data = intersects[0].object.userData;
                const sym = symbols[data.id] || "";
                const statusDiv = document.getElementById('status');
                statusDiv.innerHTML = `No.${data.id} <span style="font-size:1.2em; color:#fff;">${sym}</span> [${data.type}-block]`;
                const originalColor = intersects[0].object.material.color.getHex();
                intersects[0].object.material.emissive.setHex(0xffffff);
                setTimeout(() => { intersects[0].object.material.emissive.setHex(0x000000); }, 200);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
