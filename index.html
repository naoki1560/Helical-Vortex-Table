<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Helical Vortex Periodic Table</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: "Helvetica Neue", Arial, sans-serif; }
        
        #info {
            position: absolute; top: 0; left: 0; width: 100%;
            pointer-events: none; z-index: 10; padding: 15px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0) 100%);
        }
        h1 { margin: 0; font-size: 20px; color: #00ffff; letter-spacing: 1px; text-shadow: 0 0 5px #00ffff; }
        #status { font-size: 15px; color: #ff00ff; font-weight: bold; margin-top: 5px; display:block; }
        
        #btn-container {
            position: absolute; bottom: 30px; right: 30px;
            display: flex; gap: 15px; z-index: 20;
        }
        .hud-btn {
            background: rgba(0, 255, 255, 0.15); border: 2px solid #00ffff;
            color: #00ffff; padding: 12px 20px; border-radius: 30px;
            font-size: 14px; cursor: pointer; backdrop-filter: blur(5px);
            transition: all 0.3s; font-weight: bold; letter-spacing: 1px;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }
        .hud-btn:active, .hud-btn.active { background: #00ffff; color: #000; box-shadow: 0 0 20px #00ffff; }

        #modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 30; justify-content: center; align-items: center; padding: 20px; box-sizing: border-box; }
        #modal-content { background: #111; border: 1px solid #333; padding: 30px; max-width: 600px; width: 100%; border-radius: 12px; position: relative; box-shadow: 0 0 30px rgba(0, 255, 255, 0.3); }
        #close-btn { position: absolute; top: 15px; right: 20px; font-size: 28px; color: #666; cursor: pointer; }
        h2 { color: #00ffff; margin-top: 0; font-size: 22px; border-bottom: 2px solid #333; padding-bottom: 15px; margin-bottom: 20px;}
        .theory-text { font-size: 16px; line-height: 1.8; color: #ccc; margin-bottom: 20px; }
        strong { color: #fff; }
    </style>
</head>
<body>
    <div id="info">
        <h1>Helical Vortex Periodic Table</h1>
        <span id="status">Tap atom for details</span>
    </div>

    <div id="btn-container">
        <button id="view-btn" class="hud-btn">VIEW: DYNAMIC</button>
        <button id="theory-btn" class="hud-btn">THEORY</button>
    </div>

    <div id="modal">
        <div id="modal-content">
            <span id="close-btn">&times;</span>
            <h2>Why Helical Vortex?</h2>
            <div class="theory-text">
                <p><strong>1. Unbroken Continuity</strong><br>
                Traditional tables fragment the natural sequence. This model visualizes atomic number (Z) as a single, <strong>continuous helical flow</strong>, reflecting the true nature of matter's progression.</p>
                <p><strong>2. Perfect Group Alignment</strong><br>
                Switch to the <strong>Dynamic View</strong>. Elements of the same chemical group (like Alkali metals) align precisely in radial spokes, revealing the underlying cyclical order.</p>
                <p><strong>3. Natural Integration</strong><br>
                The f-block (Lanthanides/Actinides) is logically integrated between the s and d blocks, not exiled to a footnote, seamlessly completing the 32-column structure.</p>
            </div>
            <div style="font-size:14px; color:#666; text-align:right; margin-top:20px;">Designed by Naoki Kiryu</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
        const symbols = ["","H","He","Li","Be","B","C","N","O","F","Ne","Na","Mg","Al","Si","P","S","Cl","Ar","K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr","Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe","Cs","Ba","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu","Hf","Ta","W","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn","Fr","Ra","Ac","Th","Pa","U","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr","Rf","Db","Sg","Bh","Hs","Mt","Ds","Rg","Cn","Nh","Fl","Mc","Lv","Ts","Og"];
        
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 5000);
        // 初期位置：少し引いた斜め上
        const defaultPos = {x:0, y:150, z:400};
        camera.position.set(defaultPos.x, defaultPos.y, defaultPos.z);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.1; controls.rotateSpeed = 1.2;
        controls.minDistance = 100; controls.maxDistance = 1500;

        scene.add(new THREE.AmbientLight(0xaaaaaa, 0.8));
        const light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(100, 200, 100);
        scene.add(light);
        const light2 = new THREE.DirectionalLight(0xffffff, 0.5);
        light2.position.set(-100, -200, -100);
        scene.add(light2);

        function getColumnIndex(z) {
            if (z === 1) return 0; if (z === 2) return 31;
            if (z >= 3 && z <= 18) { const o = (z <= 10) ? 2 : 10; let l = z - o; return (l <= 2) ? l - 1 : l + 23; }
            if (z >= 19 && z <= 54) { const o = (z <= 36) ? 18 : 36; let l = z - o; if (l <= 2) return l - 1; if (l <= 12) return l + 13; return l + 13; }
            if (z >= 55) { const o = (z <= 86) ? 54 : 86; let l = z - o; return l - 1; }
            return 0;
        }

        const elements = [];
        const colors = { s: 0xff4444, p: 0xffff44, d: 0x4444ff, f: 0x44ff44, future: 0xff00ff };
        const clickableObjects = [];

        for (let z = 1; z <= 118; z++) {
            let color = colors.d, type = "d";
            const colIndex = getColumnIndex(z);
            if (colIndex <= 1) { color = colors.s; type="s"; }
            else if (colIndex >= 2 && colIndex <= 15) { color = colors.f; type="f"; }
            else if (colIndex >= 16 && colIndex <= 25) { color = colors.d; type="d"; }
            else { color = colors.p; type="p"; }

            const angleStep = (Math.PI * 2) / 32;
            let period = 1;
            if (z > 2) period = 2; if (z > 10) period = 3; if (z > 18) period = 4;
            if (z > 36) period = 5; if (z > 54) period = 6; if (z > 86) period = 7;

            const theta = -colIndex * angleStep - (Math.PI/2);
            // ★修正：全体を広げるため、半径の基本値と係数を大きく設定
            const radius = 100 + (period * 12); 
            // ★修正：高さの差も少し広げて見やすく
            const y = -z * 1.2 + 80; 
            
            const x = radius * Math.cos(theta);
            const z_pos = radius * Math.sin(theta);
            elements.push({ z: z, color: color, type: type, pos: new THREE.Vector3(x, y, z_pos) });
        }

        // ★修正：全体が広がったので、球体と文字も少し大きく
        const atomGeo = new THREE.SphereGeometry(2.5, 16, 16);
        const group = new THREE.Group();

        function makeLabel(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 128; canvas.height = 128; // キャンバス解像度UP
            ctx.fillStyle = "white";
            ctx.font = "bold 80px Arial"; // フォントサイズUP
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(text, 64, 64);
            const texture = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: texture, sizeAttenuation: false, depthTest: false });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(0.04, 0.04, 1); // スケール調整
            return sprite;
        }

        elements.forEach(el => {
            const mat = new THREE.MeshPhongMaterial({ color: el.color, shininess: 80 });
            const atom = new THREE.Mesh(atomGeo, mat);
            atom.position.copy(el.pos);
            atom.userData = { id: el.z, type: el.type };
            group.add(atom);
            clickableObjects.push(atom);
            const label = makeLabel(symbols[el.z] || String(el.z));
            label.position.copy(el.pos); label.center.set(0.5, -0.5); group.add(label);
        });
        scene.add(group);

        // ビュー制御（ダイナミック視点）
        const viewBtn = document.getElementById('view-btn');
        let isTopView = false;
        viewBtn.onclick = () => {
            isTopView = !isTopView;
            viewBtn.innerText = isTopView ? "VIEW: RESET" : "VIEW: DYNAMIC";
            viewBtn.classList.toggle('active');
            
            // ★修正：真上(0,Y,0)ではなく、斜め上空手前(0, Y, Z)に移動
            const targetPos = isTopView ? {x:0, y:450, z:250} : defaultPos;

            new TWEEN.Tween(camera.position)
                .to(targetPos, 1200) // 少しゆっくりリッチに
                .easing(TWEEN.Easing.Cubic.InOut)
                .onUpdate(() => controls.update())
                .start();
                
            // 固定モードでも少しだけ動かせるようにして「覗き込む」感を出す
            if(isTopView) {
                controls.enableRotate = false; 
                // lookAtは原点のままでOK。斜め上から見下ろす形になる。
            } else {
                controls.enableRotate = true;
            }
        };

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let touchStartX=0, touchStartY=0;
        renderer.domElement.addEventListener('touchstart', (e)=>{ if(e.touches.length===1){ touchStartX=e.touches[0].clientX; touchStartY=e.touches[0].clientY; } }, {passive:false});
        renderer.domElement.addEventListener('touchend', (e)=>{ if(e.changedTouches.length===1 && Math.abs(e.changedTouches[0].clientX-touchStartX)<10 && Math.abs(e.changedTouches[0].clientY-touchStartY)<10){ checkIntersects(e.changedTouches[0].clientX, e.changedTouches[0].clientY); } });
        renderer.domElement.addEventListener('click', (e)=>{ checkIntersects(e.clientX, e.clientY); });

        function checkIntersects(x, y) {
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(clickableObjects);
            if (intersects.length > 0) {
                const data = intersects[0].object.userData;
                const sym = symbols[data.id] || "";
                document.getElementById('status').innerHTML = `No.${data.id} <span style="font-size:1.3em; color:#fff;">${sym}</span> [${data.type}-block]`;
                intersects[0].object.material.emissive.setHex(0xffffff);
                setTimeout(() => { intersects[0].object.material.emissive.setHex(0x000000); }, 300);
            }
        }

        const modal = document.getElementById('modal');
        document.getElementById('theory-btn').onclick = () => modal.style.display = "flex";
        document.getElementById('close-btn').onclick = () => modal.style.display = "none";
        window.onclick = (e) => { if (e.target == modal) modal.style.display = "none"; }

        function animate(time) { requestAnimationFrame(animate); TWEEN.update(time); controls.update(); renderer.render(scene, camera); }
        animate();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
